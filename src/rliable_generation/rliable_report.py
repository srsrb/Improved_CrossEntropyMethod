from rliable import library as rly
from rliable import metrics
from rliable import plot_utils
import bbrl_examples.algos.cem.rliable_generation.rliable_helpers as h
import numpy as np
import matplotlib.pyplot as plt

class rliable_Analyzer():

    def __init__(self, algorithm_names, base_path_jsons, min_scores , max_scores ):
        """Initialisation de l'objet rliable Analyzed

        Parameters
        ----------
        algorithm_names : list[str]
            List of the names of the algorithms used ( should be the name of the corresponding JSON files. For example, if algo1, algo2 and algo3 are used in a simulation, the corresponding JSON files should be names algo1,json, algo2.json, algo3.json)
        base_path_jsons : str
            path to the folder containing all input JSON files generated by the class `make_json` 
        min_scores : dict[str,list[int]]
            Dict containing the lists of the different minimas for every sample of each game :
            >>> {
                jeu1 : min_jeu1,
                jeu2:min_jeu2
            }
            Used for the normalization of the scores
        
        max_scores : dict[str,list[int]]
            Dict containing the lists of the different minimas for every sample of each game :
            >>> {
                jeu1 : max_jeu1,
                jeu2:max_jeu2
            }
            Used for the normalization of the scores
        """

        self.base_path= base_path_jsons
        # list of all jsons dictionnaries corresponding to the different algorithms
        lst_json_dicts  =   [ h.load_json(algo,base_path_jsons) for algo in algorithm_names ] 
        
        ls_score_matrix =   [   h.create_score_matrix (dict,min_scores,max_scores) for dict in lst_json_dicts  ]
        ls_score_matrix_all_gen =    [   h.create_score_matrix_all_gen(dict,min_scores,max_scores) for dict in lst_json_dicts  ]
        
        self.score_matrix_all_gen_dict = h.zip_to_dictionnary(algorithm_names,ls_score_matrix)
        self.score_matrix_dict =  h.zip_to_dictionnary(algorithm_names,ls_score_matrix_all_gen)
        self.algorithms = algorithm_names
    
    def plot_aggregate_metrics(self):
        
        algorithms =  self.algorithms

        # Load ALE scores as a dictionary mapping algorithms to their human normalized
        # score matrices, each of which is of size `(num_runs x num_games)`.
        normalized_score_dict = self.score_matrix_dict
        
        aggregate_func = lambda x: np.array([
        metrics.aggregate_median(x),
        metrics.aggregate_iqm(x),
        metrics.aggregate_mean(x),
        metrics.aggregate_optimality_gap(x)])
        aggregate_scores, aggregate_score_cis = rly.get_interval_estimates(
        normalized_score_dict, aggregate_func, reps=50000)
        fig, axes = plot_utils.plot_interval_estimates(
        aggregate_scores, aggregate_score_cis,
        metric_names=['Median', 'IQM', 'Mean', 'Optimality Gap'],
        algorithms=algorithms, xlabel='Normalized Score')
        plt.legend()
        print("Ici!")
        plt.show()

    def plot_probability_improvement(self, list_pairs):
        #PAS UTILISABLE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # Load ProcGen scores as a dictionary containing pairs of normalized score
        # matrices for pairs of algorithms we want to compare
        procgen_algorithm_pairs = h.make_procgen_pairs(list_pairs,self.score_matrix_dict)
        average_probabilities, average_prob_cis = rly.get_interval_estimates(
        procgen_algorithm_pairs, metrics.probability_of_improvement, reps=2000)
        ax = plot_utils.plot_probability_of_improvement(average_probabilities, average_prob_cis)

    def plot_sample_efficiency_curve(self):
        algorithms =self.algorithms
        # Load ALE scores as a dictionary mapping algorithms to their human normalized
        # score matrices across all 200 million frames, each of which is of size
        # `(num_runs x num_games x 200)` where scores are recorded every million frame.
        ale_all_frames_scores_dict = self.score_matrix_all_gen_dict
        print(ale_all_frames_scores_dict)
        number_generations = np.size(ale_all_frames_scores_dict[self.algorithms[0]][0,0],0) 
        print("mon nombre de GEneratiooooin@@@@@@@@@",number_generations)  # frames = generations
        
        frames = np.array([k for k in range(0,number_generations,2)]) 
        print(frames)
        ale_frames_scores_dict = {algorithm: score[:, :, frames] for algorithm, score
                            in ale_all_frames_scores_dict.items()}
        iqm = lambda scores: np.array([metrics.aggregate_iqm(scores[..., frame])
                                for frame in range(scores.shape[-1])])
        iqm_scores, iqm_cis = rly.get_interval_estimates(
        ale_frames_scores_dict, iqm, reps=50000)
        ax  = plot_utils.plot_sample_efficiency_curve(
            frames+1, iqm_scores, iqm_cis, algorithms=algorithms,
            xlabel=r'Generation',
            ylabel='IQM Normalized Score')
        plt.show()
        return ax 
        
    def plot_performance_profiles(self):
        import seaborn as sns

        sns.set_style("white")

        # Load ALE scores as a dictionary mapping algorithms to their human normalized
        # score matrices, each of which is of size `(num_runs x num_games)`.
        atari_200m_normalized_score_dict = self.score_matrix_dict
        # Human normalized score thresholds
        atari_200m_thresholds = np.linspace(0.0, 8.0, 81)
        score_distributions, score_distributions_cis = rly.create_performance_profile(
        atari_200m_normalized_score_dict, atari_200m_thresholds)
        # Plot score distributions
        fig, ax = plt.subplots(ncols=1, figsize=(7, 5))
        plot_utils.plot_performance_profiles(
        score_distributions, atari_200m_thresholds,
        performance_profile_cis=score_distributions_cis,
        colors=dict(zip(self.algorithms, sns.color_palette('colorblind'))),
        xlabel=r'Human Normalized Score $(\tau)$',
        ax=ax)
        print("ii")
        plt.show()

